// Shopping list module with quantity support
let selectedStore = '';
let shoppingList = [];
let allProducts = [];
let pendingItem = null; // Item waiting for product selection confirmation
// Toggle to use live Open Food Facts via backend proxy
const useLiveOFF = true;

document.addEventListener('DOMContentLoaded', async () => {
    await loadStores();
    await loadAllProducts();

    const storeSelect = document.getElementById('store-select');
    const quantityInput = document.getElementById('quantity-input');
    const itemInput = document.getElementById('item-input');
    const addBtn = document.getElementById('add-btn');
    const clearBtn = document.getElementById('clear-btn');

    storeSelect.addEventListener('change', (e) => {
        selectedStore = e.target.value;
        renderList();
    });

    addBtn.addEventListener('click', () => addItem());
    itemInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') addItem();
    });
    quantityInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') itemInput.focus();
    });

    clearBtn.addEventListener('click', () => {
        if (confirm('Einkaufsliste wirklich leeren?')) {
            shoppingList = [];
            renderList();
        }
    });

    // Autocomplete wiring for item input
    try {
        setupItemAutocomplete(itemInput);
    } catch (e) {
        console.warn('Autocomplete setup failed:', e);
    }
});

async function loadStores() {
    try {
        // Always fetch local DB products to prefer store-specific matches
        const res = await fetch('/api/v1/product_locations');
        const data = await res.json();
        allProducts = Array.isArray(data) ? data : [];

        // Build store list: static popular stores + stores from DB
        const staticStores = ['REWE', 'EDEKA', 'ALDI', 'LIDL', 'PENNY', 'NETTO', 'dm', 'ROSSMANN'];
        const dbStores = [...new Set(allProducts.map(p => p.store_name))];
        let stores = [...new Set([...staticStores, ...dbStores])].filter(Boolean).sort();
        const select = document.getElementById('store-select');
        stores.forEach(store => {
            const opt = document.createElement('option');
            opt.value = store;
            opt.textContent = store;
            select.appendChild(opt);
        });
    } catch (err) {
        console.error('Error loading stores:', err);
    }
}

async function loadAllProducts() {
    // Already loaded in loadStores
}
// Autocomplete using OFF proxy
function setupItemAutocomplete(inputEl) {
    const acEl = document.getElementById('item-autocomplete');
    if (!inputEl || !acEl) return;

    let acAbort = null;
    let hideTimeout = null;

    const hide = () => {
        acEl.style.display = 'none';
        acEl.innerHTML = '';
    };

    const show = (html) => {
        acEl.innerHTML = html;
        acEl.style.display = 'block';
    };

    const fetchSuggestions = async (q) => {
        if (acAbort) acAbort.abort();
        const ctrl = new AbortController();
        acAbort = ctrl;
        try {
            const url = `/api/v1/openfoodfacts/autocomplete?query=${encodeURIComponent(q)}&limit=8`;
            const res = await fetch(url, { signal: ctrl.signal });
            if (!res.ok) throw new Error('ac failed');
            return await res.json();
        } catch (e) {
            return [];
        }
    };

    inputEl.addEventListener('input', async () => {
        const q = inputEl.value.trim();
        if (q.length < 2) { hide(); return; }
        const items = await fetchSuggestions(q);
        if (!items || items.length === 0) { hide(); return; }
        const html = items.map(it => `
            <div class="ac-item" data-title="${(it.display || '').replace(/"/g, '&quot;')}">
                ${it.image_url ? `<img src="${it.image_url}" onerror="this.style.display='none'" alt="" style="width:40px;height:40px;border-radius:4px;object-fit:cover;">` : '<div style="width:40px;height:40px;border-radius:4px;background:#e5e7eb;display:flex;align-items:center;justify-content:center;">üì¶</div>'}
                <div>
                    <div class="ac-title">${it.display || ''}</div>
                    ${it.barcode ? `<div class="ac-sub">${it.barcode}</div>` : ''}
                </div>
            </div>
        `).join('');
        show(html);
    });

    acEl.addEventListener('mousedown', (e) => {
        const item = e.target.closest('.ac-item');
        if (!item) return;
        const title = item.getAttribute('data-title') || '';
        inputEl.value = title;
        hide();
        // Focus quantity next to speed up flow
        const qEl = document.getElementById('quantity-input');
        if (qEl) qEl.focus();
    });

    inputEl.addEventListener('blur', () => {
        hideTimeout = setTimeout(hide, 120);
    });
    inputEl.addEventListener('focus', () => {
        if (hideTimeout) { clearTimeout(hideTimeout); hideTimeout = null; }
    });
}

// Live OFF fetch via backend proxy
async function fetchOffProducts(query, pageSize = 25) {
    const params = new URLSearchParams({
        query: query,
        country: 'de',
        page: '1',
        page_size: String(pageSize)
    });
    const res = await fetch(`/api/v1/openfoodfacts/search?${params.toString()}`);
    if (!res.ok) throw new Error('OFF fetch failed');
    const data = await res.json();
    return data.products || [];
}

// Fuzzy matching helper: Levenshtein distance
function levenshteinDistance(a, b) {
    const an = a.length;
    const bn = b.length;
    if (an === 0) return bn;
    if (bn === 0) return an;

    const matrix = Array(bn + 1).fill(null).map(() => Array(an + 1).fill(null));

    for (let i = 0; i <= an; i++) matrix[0][i] = i;
    for (let j = 0; j <= bn; j++) matrix[j][0] = j;

    for (let j = 1; j <= bn; j++) {
        for (let i = 1; i <= an; i++) {
            const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[j][i] = Math.min(
                matrix[j][i - 1] + 1,
                matrix[j - 1][i] + 1,
                matrix[j - 1][i - 1] + indicator
            );
        }
    }

    return matrix[bn][an];
}

// Synonym dictionary
const SYNONYMS = {
    'bio': ['√∂ko', 'organic', 'demeter', 'bioland', 'naturland'],
    'milch': ['h-milch', 'frischmilch', 'vollmilch', 'fettarme'],
    'joghurt': ['yoghurt', 'jogurt', 'yogurt'],
    'k√§se': ['kaese', 'cheese'],
    'wurst': ['aufschnitt', 'fleischwurst'],
    'brot': ['vollkornbrot', 'wei√übrot', 'weissbrot', 'toast']
};

// Category keywords
const CATEGORIES = {
    'obst': ['apfel', 'birne', 'banane', 'orange', 'erdbeere', 'kirsche', 'pflaume', 'pfirsich', 'melone', 'traube'],
    'gem√ºse': ['tomate', 'gurke', 'paprika', 'salat', 'm√∂hre', 'karotte', 'zwiebel', 'kartoffel', 'kohl', 'brokkoli'],
    'milchprodukte': ['milch', 'joghurt', 'k√§se', 'quark', 'sahne', 'butter', 'creme'],
    'fleisch': ['rind', 'schwein', 'h√§hnchen', 'huhn', 'pute', 'wurst', 'schinken'],
    'getr√§nke': ['wasser', 'saft', 'limonade', 'cola', 'tee', 'kaffee', 'bier', 'wein']
};

// Brand keywords (common brands)
const BRANDS = ['danone', 'm√ºller', 'arla', 'weihenstephan', 'landliebe', 'b√§renmarke', 'milram', 'nestl√©', 'ferrero', 'nutella', 'coca-cola', 'pepsi', 'dr. oetker', 'knorr', 'maggi'];

// Map OFF eco/nutri grades to numeric scores (A best)
const GRADE_SCORE = { 'A': 1.0, 'B': 0.8, 'C': 0.6, 'D': 0.4, 'E': 0.2 };

function computeFairScore(product, source) {
    // Comprehensive fairness: eco, nutrition, ethics, verification
    const eco = (product.ecoscore || product.ecoscore_grade || '').toString().toUpperCase();
    const nutri = (product.nutriscore || product.nutriscore_grade || '').toString().toUpperCase();
    const ecoScore = GRADE_SCORE[eco] || 0;
    const nutriScore = GRADE_SCORE[nutri] || 0;

    // Ethics score (0.0-1.0, from backend)
    const ethicsScore = product.ethics_score || 0.6; // Default neutral if missing

    const verifiedBoost = product.status === 'verified' ? 0.05 : 0;
    const localBoost = source === 'local' ? 0.03 : 0;

    // Weighted formula: 40% eco, 30% ethics, 20% nutri, 10% verified/local
    return (ecoScore * 0.4) + (ethicsScore * 0.3) + (nutriScore * 0.2) + verifiedBoost + localBoost;
}

function deduplicateCandidates(candidates) {
    // Group by barcode or normalized identifier to merge duplicates
    const groups = new Map();

    for (const cand of candidates) {
        const p = cand.product;
        // Use barcode as primary key, fallback to normalized product name
        const key = p.barcode || normalizeProductName(p.product_identifier || p.product_name || '');

        if (!groups.has(key)) {
            groups.set(key, []);
        }
        groups.get(key).push(cand);
    }

    // For each group, prefer local over OFF, then best score
    const deduped = [];
    for (const [key, items] of groups.entries()) {
        if (items.length === 1) {
            deduped.push(items[0]);
            continue;
        }

        // Sort: local first, then by score
        items.sort((a, b) => {
            if (a.source !== b.source) return a.source === 'local' ? -1 : 1;
            return b.score - a.score;
        });

        // Take the best (local if available, otherwise best OFF)
        const best = items[0];

        // Merge data: prefer local aisle/shelf, but keep OFF eco/nutri if missing
        if (items.length > 1) {
            const local = items.find(i => i.source === 'local');
            const off = items.find(i => i.source === 'off');

            if (local && off) {
                // Enrich local with OFF data
                if (!local.product.ecoscore && off.product.ecoscore) {
                    local.product.ecoscore = off.product.ecoscore;
                    local.product.ecoscore_grade = off.product.ecoscore_grade;
                }
                if (!local.product.nutriscore && off.product.nutriscore) {
                    local.product.nutriscore = off.product.nutriscore;
                    local.product.nutriscore_grade = off.product.nutriscore_grade;
                }
                if (!local.product.image_url && off.product.image_url) {
                    local.product.image_url = off.product.image_url;
                }
            }
        }

        deduped.push(best);
    }

    return deduped;
}

function normalizeProductName(name) {
    // Normalize product name for deduplication: lowercase, remove special chars, collapse whitespace
    return name.toLowerCase()
        .replace(/[^a-z0-9√§√∂√º√ü\s]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
}

function calculateUnitPrice(product) {
    // Calculate price per kg or L for comparison
    const price = product.current_price || product.estimated_price;
    if (!price) return null;

    const amount = product.size_amount;
    const unit = (product.size_unit || '').toLowerCase();

    if (!amount || !unit) return null;

    // Normalize to per kg or per L
    if (unit === 'g' || unit === 'kg') {
        const kg = unit === 'g' ? amount / 1000 : amount;
        return { value: price / kg, unit: 'kg', display: `${(price / kg).toFixed(2)} ‚Ç¨/kg` };
    } else if (unit === 'ml' || unit === 'l') {
        const l = unit === 'ml' ? amount / 1000 : amount;
        return { value: price / l, unit: 'l', display: `${(price / l).toFixed(2)} ‚Ç¨/L` };
    }

    return null;
}

function expandQueryWithSynonyms(query) {
    const q = query.toLowerCase().trim();
    const words = q.split(/\s+/);
    const expanded = new Set([q]);

    words.forEach(word => {
        // Check if word is in synonym dict
        for (const [key, synonyms] of Object.entries(SYNONYMS)) {
            if (word === key || synonyms.includes(word)) {
                expanded.add(key);
                synonyms.forEach(syn => expanded.add(syn));
            }
        }
    });

    return Array.from(expanded);
}

function expandQueryWithCategories(query) {
    const q = query.toLowerCase().trim();
    const matches = [];

    for (const [category, keywords] of Object.entries(CATEGORIES)) {
        if (q === category) {
            // User typed a category name - return all keywords in that category
            return keywords;
        }
    }

    return [q];
}

function multiTokenMatch(query, target) {
    // Split query into tokens
    const queryTokens = query.toLowerCase().trim().split(/\s+/).filter(Boolean);
    const targetTokens = target.toLowerCase().trim().split(/\s+/).filter(Boolean);

    if (queryTokens.length === 0) return 0;

    // Calculate how many query tokens are found in target
    let matchedTokens = 0;
    queryTokens.forEach(qToken => {
        const found = targetTokens.some(tToken => {
            // Exact match or fuzzy match per token
            if (tToken.includes(qToken)) return true;
            const dist = levenshteinDistance(qToken, tToken);
            const similarity = 1 - (dist / Math.max(qToken.length, tToken.length));
            return similarity >= 0.7;
        });
        if (found) matchedTokens++;
    });

    return matchedTokens / queryTokens.length;
}

function brandBoost(query, target) {
    // Check if query contains a brand name
    const q = query.toLowerCase();
    const t = target.toLowerCase();

    for (const brand of BRANDS) {
        if (q.includes(brand) && t.includes(brand)) {
            return 0.2; // Boost score by 20%
        }
    }
    return 0;
}

function fuzzyMatch(query, target, threshold = 0.6) {
    // Normalize: lowercase, trim
    const q = query.toLowerCase().trim();
    const t = target.toLowerCase().trim();

    // Exact substring match - highest score
    if (t.includes(q)) return 1.0;

    // Check if query is a single word and target contains it as a word
    const qWords = q.split(/\s+/);
    const tWords = t.split(/\s+/);

    // Single word exact match bonus
    if (qWords.length === 1 && tWords.some(w => w === q)) {
        return 0.95;
    }

    // Multi-token match (for "griechischer jogurt" -> "Joghurt Griechisch")
    const multiScore = multiTokenMatch(q, t);
    if (multiScore >= 0.7) return multiScore;

    // Levenshtein for fuzzy matching - but be stricter
    const distance = levenshteinDistance(q, t);
    const maxLen = Math.max(q.length, t.length);
    const similarity = 1 - (distance / maxLen);

    // Increase threshold to avoid false positives
    return similarity >= Math.max(threshold, 0.7) ? similarity : 0;
}

function parseQuantity(quantityStr) {
    // Parse "300g", "2L", "5x", "1.5kg" etc.
    if (!quantityStr) return null;
    const match = quantityStr.trim().match(/^([\d.,]+)\s*(g|kg|ml|l|x|st√ºck|st)?$/i);
    if (!match) return null;

    let amount = parseFloat(match[1].replace(',', '.'));
    let unit = (match[2] || 'x').toLowerCase();

    // Normalize to base units (g, ml, x)
    if (unit === 'kg') { amount *= 1000; unit = 'g'; }
    if (unit === 'l') { amount *= 1000; unit = 'ml'; }
    if (unit === 'st√ºck' || unit === 'st') { unit = 'x'; }

    return { amount, unit };
}

function extractProductQuantity(product) {
    // Priority 1: Use size_amount and size_unit from DB if available
    if (product.size_amount && product.size_unit) {
        let amount = product.size_amount;
        let unit = product.size_unit.toLowerCase();

        // Normalize
        if (unit === 'kg') { amount *= 1000; unit = 'g'; }
        if (unit === 'l') { amount *= 1000; unit = 'ml'; }
        if (unit === 'st√ºck' || unit === 'st') { unit = 'x'; }

        return { amount, unit };
    }

    // Priority 2: Extract from product name like "Joghurt 150g" or "Milch 1L"
    const match = product.product_identifier.match(/([\d.,]+)\s*(g|kg|ml|l|st√ºck|st)$/i);
    if (!match) return null;

    let amount = parseFloat(match[1].replace(',', '.'));
    let unit = match[2].toLowerCase();

    if (unit === 'kg') { amount *= 1000; unit = 'g'; }
    if (unit === 'l') { amount *= 1000; unit = 'ml'; }
    if (unit === 'st√ºck' || unit === 'st') { unit = 'x'; }

    return { amount, unit };
}

function calculateOptimalQuantity(needed, productQty) {
    // Calculate how many units of productQty are needed to meet/exceed needed
    if (!needed || !productQty) return null;
    if (needed.unit !== productQty.unit) return null; // Units must match

    const count = Math.ceil(needed.amount / productQty.amount);
    const totalAmount = count * productQty.amount;

    return { count, totalAmount, unit: needed.unit };
}

function addItem() {
    const quantityInput = document.getElementById('quantity-input');
    const itemInput = document.getElementById('item-input');

    const quantityStr = quantityInput.value.trim();
    const query = itemInput.value.trim();

    if (!query) return;
    if (!selectedStore) {
        alert('Bitte w√§hle zuerst einen Laden aus!');
        return;
    }

    const needed = parseQuantity(quantityStr);

    // Create pending item (not added to list yet)
    pendingItem = {
        query,
        needed,
        matched: null,
        matchScore: 0,
        matchedSource: null,
        calculation: null,
        suggestions: []
    };

    quantityInput.value = '';
    itemInput.value = '';

    // Show pending selection UI and match products
    showPendingSelection();
}

async function showPendingSelection() {
    const container = document.getElementById('pending-selection');
